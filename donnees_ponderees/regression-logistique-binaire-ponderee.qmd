# R√©gression logistique binaire pond√©r√©e {#sec-regression-logistique-binaire-ponderee}

Nous avons abord√© la r√©gression logistique binaire non pond√©r√©e dans un chapitre d√©di√©, cf. @sec-regression-logistique-binaire. Elle se r√©alise classiquement avec la fonction `glm()` en sp√©cifiant `family = binomial`.

Lorsque l'on utilise des donn√©es d'enqu√™tes, l'approche est similaire sauf que l'on aura recours √† la fonction `survey::svyglm()` qui sait g√©rer des objets `{survey}`¬†: non seulement la pond√©ration sera prise en compte, mais le calcul des intervalles de confiance et des p-valeurs sera ajust√© en fonction du plan d'√©chantillonnage.

## Donn√©es des exemples

Nous allons reprendre les m√™me donn√©es issues de l'enqu√™te *Histoire de vie 2003*, mais en tenant compte cette fois-ci des poids de pond√©ration fourni dans la variable *poids*.

```{r}
#| message: false
library(tidyverse)
library(labelled)
data(hdv2003, package = "questionr")
d <-
  hdv2003 |> 
  mutate(
    sexe = sexe |> fct_relevel("Femme"),
    groupe_ages = age |>
      cut(
        c(18, 25, 45, 65, 99),
        right = FALSE,
        include.lowest = TRUE,
        labels = c("18-24 ans", "25-44 ans",
                   "45-64 ans", "65 ans et plus")
      ),
    etudes = nivetud |> 
      fct_recode(
        "Primaire" = "N'a jamais fait d'etudes",
        "Primaire" = "A arrete ses etudes, avant la derniere annee d'etudes primaires",
        "Primaire" = "Derniere annee d'etudes primaires",
        "Secondaire" = "1er cycle",
        "Secondaire" = "2eme cycle",
        "Technique / Professionnel" = "Enseignement technique ou professionnel court",
        "Technique / Professionnel" = "Enseignement technique ou professionnel long",
        "Sup√©rieur" = "Enseignement superieur y compris technique superieur"
    ) |> 
    fct_na_value_to_level("Non document√©")  
  ) |> 
  set_variable_labels(
    sport = "Pratique un sport ?",
    sexe = "Sexe",
    groupe_ages = "Groupe d'√¢ges",
    etudes = "Niveau d'√©tudes",
    relig = "Rapport √† la religion",
    heures.tv = "Heures de t√©l√©vision / jour",
    poids = "Pond√©ration de l'enqu√™te"
  )
```

Il ne nous reste qu'√† d√©finir notre objet `{survey}` en sp√©cifiant la pond√©ration fournie avec l'enqu√™te. La documentation ne mentionne ni strates ni grappes.

```{r}
#| message: false
library(srvyr)
library(survey)
dp <- d |> 
  as_survey_design(weights = poids)
```

## Calcul de la r√©gression logistique binaire

La syntaxe de `survey::svyglm()` est similaire √† celle de `glm()` sauf qu'elle a un argument `design` au lieu de `data`.

La plupart du temps, les poids de pond√©ration ne sont pas des nombres entiers, mais des nombres d√©cimaux. Or, la famille de mod√®les binomiaux repose sur des nombres entiers de succ√®s et d'√©checs. Avec une version r√©cente[^regression-logistique-binaire-ponderee-1] de **R**, cela n'est pas probl√©matique. Nous aurons simplement un avertissement.

[^regression-logistique-binaire-ponderee-1]: Si vous utilisez une version ancienne de **R**, cela n'√©tait tout simplement pas possible. Vous obteniez un message d'erreur et le mod√®le n'√©tait pas calcul√©. Si c'est votre cas, optez pour un mod√®le quasi-binomial ou bien mettez √† jour **R.**

```{r}
mod_binomial <- svyglm(
  sport ~ sexe + groupe_ages + etudes + relig + heures.tv,
  family = binomial,
  design = dp
)
```

Une alternative consiste √† avoir recours √† la famille quasi-binomiale, que l'on sp√©cifie avec `family = quasibinomial` et qui constitue une extension de la famille binomiale pouvant g√©rer des poids non entiers. La distribution quasi-binomiale, bien que similaire √† la distribution binomiale, poss√®de un param√®tre suppl√©mentaire ùúô qui tente de d√©crire une variance suppl√©mentaire dans les donn√©es qui ne peut √™tre expliqu√©e par une distribution binomiale seule (on parle alors de *surdispersion*). Les coefficients obtenus sont les m√™mes, mais les intervalles de confiance peuvent √™tre un peu plus large.

```{r}
mod_quasi <- svyglm(
  sport ~ sexe + groupe_ages + etudes + relig + heures.tv,
  family = quasibinomial,
  design = dp
)
```

Simple, non¬†?

## S√©lection de mod√®le

Comme pr√©c√©demment (cf. @sec-selection-modele-pas-a-pas), il est possible de proc√©der √† une s√©lection de mod√®le pas √† pas, par minimisation de l'AIC, avec `step()`.

```{r}
mod_quasi2 <- step(mod_quasi)
```

::: callout-warning
## S√©lection pas √† pas et valeurs manquantes

Nous avons abord√© dans le chapitre sur la s√©lection de mod√®le pas √† pas la probl√©matique des valeurs manquantes lors d'une s√©lection pas √† pas descendante par minimisation de l'AIC (cf. @sec-step-avec-na). La m√™me approche peut √™tre appliqu√©e avec des donn√©es pond√©r√©es, √† l'aide de la fonction `guideR::step_with_na()`, compatible avec les mod√®les `survey::svyglm()`. Il faudra n√©anmoins, dans ce cas l√†, qu'on lui passe l'objet `{survey}` ayant servi au calcul du mod√®le via l'e param√®tre'argument `design`.


```{r}
#| eval: false
mod_quasi2 <- guideR::step_with_na(mod_quasi, design = dp)
```
:::

## Affichage des r√©sultats

Nous pouvons tout √† fait utiliser `gtsumarry::tbl_regression()` avec ce type de mod√®les. De m√™me, on peut utiliser `gtsummary::add_global_p()` pour calculer les p-valeurs globales des variables ou encore `gtsummary::add_vif()` pour v√©rifier la multicolin√©arit√© (cf. @sec-multicolinearite).

```{r}
#| message: false
library(gtsummary)
theme_gtsummary_language("fr", decimal.mark = ",", big.mark = " ")
```

```{r}
#| label: tbl-regression-logistique-ponderee
#| tbl-cap: Facteurs associ√©s √† la pratique d'un sport (r√©gression logistique pond√©r√©e)
mod_quasi2 |> 
  tbl_regression(exponentiate = TRUE) |> 
  add_global_p(keep = TRUE) |> 
  add_vif() |> 
  bold_labels()
```

Pour un graphique des coefficients, nous pouvons utiliser `ggstats::ggcoef_model()`.

```{r}
#| label: fig-forest-plot-regression-logistique-ponderee
#| fig-cap: Facteurs associ√©s √† la pratique d'un sport (r√©gression logistique pond√©r√©e)
mod_quasi2 |> 
  ggstats::ggcoef_model(exponentiate = TRUE)
```

## Pr√©dictions marginales

Pour visualiser les pr√©dictions marginales moyennes du mod√®le (cf. @sec-predictions-marginales), nous pouvons utiliser `broom.helpers::plot_marginal_predictions()`.

```{r}
#| label: fig-predictions-marginales-moyennes-regression-ponderee
#| fig-cap: Pr√©dictions marginales moyennes du mod√®le pond√©r√©
mod_quasi2 |> 
  broom.helpers::plot_marginal_predictions(type = "response") |> 
  patchwork::wrap_plots() &
  scale_y_continuous(
    limits = c(0, .8),
    labels = scales::label_percent()
  )
```
